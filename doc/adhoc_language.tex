\documentclass[11pt,a4paper]{article}

% imports
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
% \usepackage{parskip}  % no-indent para
\usepackage{amssymb}  % number sets
\usepackage{syntax}   % (E)BNF

\usepackage{geometry}
\geometry{letterpaper,portrait,margin=1in}

% (E)BNF
% \usepackage{backnaur}
% \renewcommand{\bnfpo}{::=}

% judgements
\usepackage{semantic}
\reservestyle{\command}{\textbf}
\command{true,false}                                    % literals
\command{apply,closure,defun,defvar,if,lambda,let,prim} % keywords
\command{cons,nil}                                      % lists


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title

\title{The \textit{Adhoc} Language}
\author{Ross Bayer}
\date{\today}

\begin{document}
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction

\section{Introduction}

\textit{Adhoc} is a small, functional programming language developed to study
adhoc polymorphism in Hindley-Milner type systems. The language is small and
was not developed as a general-purpose language. As such, it lacks many features
expected in a modern languge and should not be used non-trivial programs. Adhoc
is a funcitonal language that provides higher-order functions, recursive
functions, strong typing, parametric polymorphism and adhoc polymorphism.

This report defines the syntax and semantics of the Adhoc language. The
implementation details of adhoc polymorphism are explained in detail.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexical Structure

\section{Lexical Structure}

The lexical structure of Adhoc are simple. The only valid characters in the
language are those representable in ASCII. Identifiers can contain a mixture of
special character and alpha-numeric. The lexical specification is denoted using
EBNF form.

% float styling
\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}[H]
\small
\renewcommand{\grammarlabel}[2]{\synt{#1}\hfill#2}
\setlength{\grammarindent}{8em}
\begin{grammar}
<digit> ::= "0" ... "9"

<digits> ::= <digit>+

<int> ::= "-"? <digits>

<float> ::= "-"? <digits> ("." <digits>)?

<alpha> ::= "a" ... "z" | "A" ... "Z"

<special> ::= "!" | "\$" | "\&" | "+" | "-" | "*" | "/" | ":" | "<" | "=" | ">" | "?"| "~" | "_" | "^"

<initial> ::= <alpha> | <special>

<subsequent> ::= <alpha> | <digit> | <special> | "."

<ident> ::= <initial> <subsequent>+

<keywork> ::= "defun"
    \alt "defvar"
    \alt "if"
    % \alt "inst"
    \alt "lambda"
    \alt "let"
    % \alt "over"
    \alt "true"
    \alt "false"
\end{grammar}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Grammar
\section{Grammar}

The grammar for the language \textbf{adhoc} is represented below in
EBNF form. It translates to a simplified AST used in the type judgements
and operational semantics below.

% float styling
\floatstyle{boxed}
\restylefloat{figure}

% grammar
\begin{figure}[H]
\small
\setlength{\grammarindent}{8em}
\renewcommand{\grammarlabel}[2]{\synt{#1}\hfill#2}
\begin{grammar}
<program> ::= <form> <program>

<form> ::= <definition>
    \alt <expression>
    % \alt <overload>
    % \alt <instance>

<definition> ::= "(" "defun" "(" <ident> <formals> ":" <type> ")" <expression> ")"
    \alt "(" "defvar" <ident> <expression> ")"

% <overload> ::= "(" "over" <ident> ")"

% <instance> ::= "(" "inst" "(" <ident> ":" <type> ")" <expression> ")"

<expression> ::= <constant>
    \alt <ident>
    \alt "(" "if" <expression> <expression> <expression> ")"
    \alt "(" "lambda" <formals> <expression> ")"
    \alt "(" "let" <bindings> <expression> ")"
    \alt <application>
    \alt "(" <expression> ")"

<type> ::= "(" <type> ")"
    \alt <ident>
    \alt "(" <ident> ")"
    \alt <ident> "->" <type>

<variable> ::= <ident> ":" <type>

<formal> ::= "(" <variable> ")"

<formals> ::= "(" <variable>+ ")"

<value> ::= <ident> <expression>

<binding> ::= "(" <value> ")"

<bindings> ::= "(" <binding>+ ")"

<application> ::= "(" <expression> <expression>+ ")"
\end{grammar}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Translation

\section{Translation}

TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type System

\section{Type Judgements}

Adhoc features a Hindley-Milner type system with parametric polymorphism.
Monotypes $\tau$ designate a concrete type, such as \verb|bool|, \verb|float|,
\verb|int| and also parametric types, such as \verb|list| and $\rightarrow$.
Polytypes, also called type schemes, allow for universal quantification over
a type variable $\alpha$ in another polytype or monotype.

% \begin{figure}[H]
% \centering
% \caption{Variables}
% \label{fig:vars}
% % \renewcommand{\arraystretch}{1.5}
% \begin{tabular}{l l}
%     Unique variables        & $u \in \mathcal{U}$ \\
%     Overloaded variables    & $o \in \mathcal{O}$ \\
%     Variables               & $x = u$ \| $o$         \\

%     Type variables          & $\alpha \in \mathcal{A}$ \\
%     Type constructors       & $T \in \mathcal{T}$   \\
%     Type schemes            & $\tau = \alpha$ | $\forall \alpha . \pi_\alpha \Rightarrow \sigma$ \\
%     Constraints on $\alpha$ & $\pi_\alpha = o_1 : \alpha \rightarrow \tau_1$, \dots, $o_n : \alpha \rightarrow \tau_n$ \\
%     Typotheses              & $\Gamma = x_1 : \sigma_1, \dots, x_n : \sigma_n$ \\
% \end{tabular}
% \end{figure}

% float styling
\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}[H]
\small
\setlength{\grammarindent}{10em}
\begin{grammar}
<monotype $\tau$> = "bool"
    \alt "float"
    \alt "int"
    \alt "list" $\tau$
    \alt $\tau_1 \rightarrow \tau_2$

<polytype $\sigma$> = $\tau$
    \alt $\forall$ $\alpha$ . $\sigma$
\end{grammar}
\end{figure}

Literals in the lanugage have their types inferred using the following
judgements.

\begin{figure}[H]
\centering
% literals
\[
    % bool
    \inference[(BOOL) ]{}{\Gamma |- \<true> : bool}
    \hspace{1em}
    \inference{}{\Gamma |- \<false> : bool}[(BOOL)]
\]
\[
    % int
    \inference[(INT)]{n \in \mathbb{Z}}{\Gamma |- n : int}
    \hspace{1em}
    % float
    \inference{n \in \mathbb{R}}{\Gamma |- n : float}[(FLOAT)]
\]
\[
    % nil
    \inference[(NIL)]{}{\Gamma |- \<nil> : list_\tau}
    \hspace{1em}
    % cons
    \inference
        {
            \Gamma |- M : \tau \\
            \Gamma |- N : \tau
        }
        {\Gamma |- \<cons>(M, N) : list_\tau}
        [(LIST)]
\]
\end{figure}

Definitions and expressions in the lanague have their types inferred using the
following judgements.

\begin{figure}[H]
\centering
\small
\[
    % variable
    \inference[(TAUT)]{}{\Gamma |- x : \sigma}
    \hspace{2em}
    % if
    \inference
        {
            \Gamma |- M_1 : bool \\
            \Gamma |- M_2 : \sigma \\
            \Gamma |- M_3 : \sigma
        }
        {\Gamma |- \<if>(M_1, M_2, M_3) : \sigma}[(IF)]
\]

\[
    % let
    \inference[(LET)]
        {
            \Gamma |- M : \tau \\
            \Gamma, M : \tau |- N : \tau'
        }
        {\Gamma |- \<let>(x, M, N) : \tau'}
    \hspace{2em}
    % lambda
    \inference
        {\Gamma, x : \tau |- M : \tau'}
        {\Gamma |- \<lambda>(x, \tau, N) : \tau'}
        [(LAMBDA)]
\]

\[
    % defun
    \inference[(DEFUN)]
        {\Gamma, x : \sigma, M : \tau' |- f : \tau -> \tau'}
        {\Gamma |- \<defun>(f, x, \tau, M, \tau') : \tau -> \tau'}
    \hspace{2em}
    % defvar
    \inference
        {\Gamma |- M : \tau}
        {\Gamma |- \<defvar>(x, M) : \tau}
        [(DEFVAR)]
\]

\[
    % apply
    \inference[(APPLY)]
        {
            \Gamma |- N : \tau \\
            \Gamma |- M : \tau -> \tau'
        }
        {\Gamma |- \<apply>(M, N) : \tau'}
\]
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Operational Semantics

\section{Operational Semantics}

The \textbf{adhoc} langauge has clearly defined operational semantics.
To allow for self-recursive functions a global environment $G$ is
threaded through. The operational semantics for the language are as
follows:

% boolean literals

\[
    \inference{}{(\<true>, \rho, G) \Downarrow (\<true>, G)}
    \hspace{1em}
    \inference{}{(\<false>, \rho, G) \Downarrow (\<false>, G)}
\]

% numbers
\[\inference{}{(n, \rho, G) \Downarrow (n, G')}\]

% variables
\[\inference{$lookup$(x, G) = v}{(x, \rho, G) \Downarrow (v, G')}\]

% if
\[
\inference
	{
 	    (M_1, \rho, G) \Downarrow (\<true>, G) \\
        (M_2, \rho, G') \Downarrow (v, G'')
    }
	{(\<if>(M_1, M_2, M_3), \rho, G) \Downarrow (v, G'')}
\hspace{1em}
\inference
	{
 	    (M_1, \rho, G) \Downarrow (\<false>, G) \\
        (M_3, \rho, G') \Downarrow (v, G'')
	}
	{(\<if>(M_1, M_2, M_3), \rho, G) \Downarrow (v, G'')}
\]

% let
\[\inference
 	{
     	(M_1, \rho, G) \Downarrow (v, G') \\
        (M_2, \rho[x \mapsto v], G') \Downarrow (v', G'')
    }
 	{(\<let>(x, M_1, M_2), \rho, G) \Downarrow (v', G'')}
\]

% lambda
\[\inference
 	{}
    {(\<lambda>(x, t_x, M), \rho, G) \Downarrow (\<closure>(x, M, \rho), G)}
\]

% defun
\[\inference
 	{}
 	{(\<defun>(f, x, t_x, M, t_M), \rho, G) \Downarrow ($_$, \rho, G[f \mapsto \<closure>(x, M, \rho)])}
\]

% defvar
\[\inference
 	{}
    {(\<defvar>(x, M), \rho, G) \Downarrow ($_$, \rho, G[x \mapsto M])}
\]

% call closure
\[\inference
 	{
     	(M, \rho, G) \Downarrow (\<closure>(x, M_c,\rho'), G') \\
      	(N, \rho, G') \Downarrow (v, \rho, G'') \\
      	(M_c, \rho'[x \mapsto v], G'') \Downarrow (v', G''')
     }
     {(\<apply>(M, N), \rho, G) \Downarrow (v', G''')}
\]

% call primitive
\[\inference
 	{
     	(M, \rho, G) \Downarrow (\<prim>(f), G') \\
      	(N, \rho, G') \Downarrow (v, \rho, G'') \\
  	    \delta(f, v) = v'
     }
 {(\<apply>(M, N), \rho, G) \Downarrow (v', G'')}
\]

% nil
\[\inference{}{(\<nil>(\tau), \rho, G) \Downarrow (\<nil>(\tau), G)}\]

% cons
\[\inference
    {
        (M, \rho, G) \Downarrow (v', G') \\
        (N, \rho, G) \Downarrow (v'', G'')
    }
    {(\<cons>(M, N), \rho, G) \Downarrow (\<cons>(v', v''), G)}
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Extensions for Adhoc-Polymorphism

\section{Extensions for Adhoc-Polymorphism}

TODO


\end{document}
